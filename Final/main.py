# -*- coding: utf-8 -*-
"""
Created on Sat May 23 22:06:08 2020

@author: 45242
"""
print("Main Testing File Starts:\n")
from TSAM import TSAM
T = TSAM()
"""
A/B means generate a B-Tree with for relation A with key of B
a # T means find data with key a in B+tree or Btree T
.x means projection
A CONTAINS a means a are in A
IS means movie can be found in latter input
key@relation means derefence a relation with key
"""
"""
Ex2(ii)
We seperate the query to 4 parts to see it more clear
query2_1 is to find all comedy movie that have got actor awards in USA in 1994(the reason to use 1994 is we don't have such movie in 2000 in our database)
query2_2 is then to check those awarded actors are not in action movie
query2_3 and query2_4 is then to check those awarded actor never write or direct Italian movies
"""
query2_1 = "MOVIES WHERE (g == comedy) WHERE (movie IS (A_AWARDS / MOVIES)) WHERE ((movie # (A_AWARDS / MOVIES).an #AWARDS.c == USA) and (movie # (A_AWARDS / MOVIES).ay == 1994))"
query2_2 = "WHERE (not (movie # (A_AWARDS / MOVIES).role#ROLES.id#(ROLES/PERSONS).movie#MOVIES.g CONTAINS action)"
query2_3 = "and (not (movie # (A_AWARDS / MOVIES).role#ROLES.id#(DIRECTORS/PERSONS).movie#MOVIES.c CONTAINS Italy))"
query2_4 = "and (not (movie # (A_AWARDS / MOVIES).role#ROLES.id#(WRITERS/PERSONS).movie#MOVIES.c CONTAINS Italy)))"
query2 = query2_1 + query2_2 + query2_3 + query2_4
print("Ex2(ii) input:\n", query2)
res = T.eval(query2)
print("Ex2(ii) Result:\n", res)




##############################
"""
Ex2(iii)
Here NeverChildren is specially written for we assume some description means children can see it, see code in TSAM.py
"""
print("\n\n")
query3 = "ROLES / PERSONS WHERE (movie # (RESTRICTIONS/MOVIES).d NeverChildren) @ PERSONS"
print("Input query for Ex2(iii) is:\n", query3)
res = T.eval(query3)
names = [e[1]+' '+ e[2] for e in res]
print("Result for Ex2(iii):")
print(names)




#############################
from Undirected_Graph import Graph
def pairs_l(la):
    if len(la) < 2:
        raise TypeError("Cannot form a pair:", la)
    pairlist = []
    for i in range(len(la) - 1):
        for j in range(i + 1, len(la)):
            pairlist.append((la[i], la[j]))
    return pairlist
def pairs_g(groups):
    allpairs = []
    for g in groups:
        pairs = pairs_l(g)
        for p in pairs:
            allpairs.append(p)
    return allpairs

"""
Ex4(i)
Here we use an Undirected_Graph to find the conected components of a graph generated by input edges(associate actors).
The resulting graph is g
We also print all the (a, b)s to visualize
"""
query5 = "NESTED(APPEARANCES/SCENES).role #ROLES.id"
res = T.eval(query5)
#print(res)
groups1 = []
for g in res:
    if len(g) > 1:
        groups1.append(g)
pairs = pairs_g(groups1)
g = Graph(pairs)
res_cclist = g.cc_undirected() #This is result as graph

reslist1 = []
for subgraph in res_cclist:
    vlist = [v for v in subgraph.vertexList]
    reslist1.extend(pairs_l(vlist))
persons = T.getRelation("PERSONS")
#derefenrce the id to person
for i in range(len(reslist1)):
    pair = reslist1[i]
    a = persons.find([pair[0]])
    a = a[1]+' '+a[2]
    b = persons.find([pair[1]])
    b = b[1]+' '+b[2]
    reslist1[i] = (a, b)
print("\nresult list for Ex4(i):\n(The result graph is in the code)\n", reslist1)




####################################
"""
Ex4(ii)
Here we use an Directed_Graph with defth-first-search to iterate all the nodes reachable for a key
With all the edges in the forest (resdg.tree), we have the result resdg
We also print all the (a, b)s to visualize
"""
from Directed_Graph import DiGraph
from BTree import BTree
query6 = "NESTED (ROLES/MOVIES).id" #get all the ids for roles in the same movie
groups2 = T.eval(query6)
#print(groups)
admirelist = []
btree_roles = BTree(T.getRelation('ROLES'), 5, 0)
btree_a_awards = BTree(T.getRelation('A_AWARDS'), 5, [0, 1, 2])
j = 0
for i in range(len(groups2)):
    if len(groups2[i]) > 1:
        admirelist.append([groups2[i]])
        admirelist[j].append([])
        for p in groups2[i]:
            roles = btree_roles.find(p)
            if roles != None:
                flag = 0
                for role in roles:
                    if flag == 0:
                        awards = btree_a_awards.find(role[1:4]) 
                        if awards != None:
                            for award in awards:
                                if award[6] == 'won':
                                    #with search in the two B-trees, we have the actors the won an award
                                    admirelist[j][1].append(p)
                                    flag = 1
                                    break
        j += 1
        
admirepairs = [] #admirelist = [[[p,p,p],[star,star,...]], ...]
                 #admirepairs = [[p,star], [p, star], .....]
for t in admirelist:
    if len(t[1]) > 0:
        for star in t[1]:
            for p in t[0]:
                if p != star:
                    admirepairs.append((p, star))

resdg = DiGraph(admirepairs)
resdg.allDFS()
reslist2 = []
for subtree in resdg.tree:
    edges = [e for e in subtree]
    reslist2.extend(edges)
persons = T.getRelation("PERSONS")
for i in range(len(reslist2)):
    pair = reslist2[i]
    a = persons.find([pair[0]])
    a = a[1]+' '+a[2]
    b = persons.find([pair[1]])
    b = b[1]+' '+b[2]
    reslist2[i] = (a, b)
print("\nResult list of Ex4(ii):\n", reslist2, '\n')

